{"version":3,"file":"worker.js","mappings":"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","sources":["webpack://edge-chat-demo/webpack/bootstrap","webpack://edge-chat-demo/webpack/runtime/define property getters","webpack://edge-chat-demo/webpack/runtime/hasOwnProperty shorthand","webpack://edge-chat-demo/webpack/runtime/make namespace object","webpack://edge-chat-demo/./src/chat.mjs"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// This is the Edge Chat Demo Worker, built using Durable Objects!\n\n// ===============================\n// Introduction to Modules\n// ===============================\n//\n// The first thing you might notice, if you are familiar with the Workers platform, is that this\n// Worker is written differently from others you may have seen. It even has a different file\n// extension. The `mjs` extension means this JavaScript is an ES Module, which, among other things,\n// means it has imports and exports. Unlike other Workers, this code doesn't use\n// `addEventListener(\"fetch\", handler)` to register its main HTTP handler; instead, it _exports_\n// a handler, as we'll see below.\n//\n// This is a new way of writing Workers that we expect to introduce more broadly in the future. We\n// like this syntax because it is *composable*: You can take two workers written this way and\n// merge them into one worker, by importing the two Workers' exported handlers yourself, and then\n// exporting a new handler that call into the other Workers as appropriate.\n//\n// This new syntax is required when using Durable Objects, because your Durable Objects are\n// implemented by classes, and those classes need to be exported. The new syntax can be used for\n// writing regular Workers (without Durable Objects) too, but for now, you must be in the Durable\n// Objects beta to be able to use the new syntax, while we work out the quirks.\n//\n// To see an example configuration for uploading module-based Workers, check out the wrangler.toml\n// file or one of our Durable Object templates for Wrangler:\n//   * https://github.com/cloudflare/durable-objects-template\n//   * https://github.com/cloudflare/durable-objects-rollup-esm\n//   * https://github.com/cloudflare/durable-objects-webpack-commonjs\n\n// ===============================\n// Required Environment\n// ===============================\n//\n// This worker, when deployed, must be configured with two environment bindings:\n// * rooms: A Durable Object namespace binding mapped to the ChatRoom class.\n// * limiters: A Durable Object namespace binding mapped to the RateLimiter class.\n//\n// Incidentally, in pre-modules Workers syntax, \"bindings\" (like KV bindings, secrets, etc.)\n// appeared in your script as global variables, but in the new modules syntax, this is no longer\n// the case. Instead, bindings are now delivered in an \"environment object\" when an event handler\n// (or Durable Object class constructor) is called. Look for the variable `env` below.\n//\n// We made this change, again, for composability: The global scope is global, but if you want to\n// call into existing code that has different environment requirements, then you need to be able\n// to pass the environment as a parameter instead.\n//\n// Once again, see the wrangler.toml file to understand how the environment is configured.\n\n// =======================================================================================\n// The regular Worker part...\n//\n// This section of the code implements a normal Worker that receives HTTP requests from external\n// clients. This part is stateless.\n\n// With the introduction of modules, we're experimenting with allowing text/data blobs to be\n// uploaded and exposed as synthetic modules. In wrangler.toml we specify a rule that files ending\n// in .html should be uploaded as \"Data\", equivalent to content-type `application/octet-stream`.\n// So when we import it as `HTML` here, we get the HTML content as an `ArrayBuffer`. This lets us\n// serve our app's static asset without relying on any separate storage. (However, the space\n// available for assets served this way is very limited; larger sites should continue to use Workers\n// KV to serve assets.)\n// import HTML from \"./chat.html\";\n// import favicon from \"./favicon.ico\";\n// import hippo from \"./compressed/blue_hippopotamus.svg\";\n\n// `handleErrors()` is a little utility function that can wrap an HTTP request handler in a\n// try/catch and return errors to the client. You probably wouldn't want to use this in production\n// code but it is convenient when debugging and iterating.\nasync function handleErrors(request, func) {\n  try {\n    return await func();\n  } catch (err) {\n    if (request.headers.get(\"Upgrade\") == \"websocket\") {\n      // Annoyingly, if we return an HTTP error in response to a WebSocket request, Chrome devtools\n      // won't show us the response body! So... let's send a WebSocket response with an error\n      // frame instead.\n      let pair = new WebSocketPair();\n      pair[1].accept();\n      pair[1].send(JSON.stringify({error: err.stack}));\n      pair[1].close(1011, \"Uncaught exception during session setup\");\n      return new Response(null, { status: 101, webSocket: pair[0] });\n    } else {\n      return new Response(err.stack, {status: 500});\n    }\n  }\n}\n\n// In modules-syntax workers, we use `export default` to export our script's main event handlers.\n// Here, we export one handler, `fetch`, for receiving HTTP requests. In pre-modules workers, the\n// fetch handler was registered using `addEventHandler(\"fetch\", event => { ... })`; this is just\n// new syntax for essentially the same thing.\n//\n// `fetch` isn't the only handler. If your worker runs on a Cron schedule, it will receive calls\n// to a handler named `scheduled`, which should be exported here in a similar way. We will be\n// adding other handlers for other types of events over time.\nexport default {\n  async fetch(request, env) {\n    return await handleErrors(request, async () => {\n      // We have received an HTTP request! Parse the URL and route the request.\n\n      let url = new URL(request.url);\n      let path = url.pathname.slice(1).split('/');\n\n      // if (!path[0]) {\n      //   // Serve our HTML at the root path.\n      //   return new Response(HTML, {headers: {\"Content-Type\": \"text/html;charset=UTF-8\"}});\n      // }\n\n      switch (path[0]) {\n        case \"api\":\n          // This is a request for `/api/...`, call the API handler.\n          return handleApiRequest(path.slice(1), request, env);\n          // case \"favicon.ico\":\n          //   return new Response(favicon, {headers: {\"Content-Type\": \"text/html;charset=UTF-8\"}});\n          // case \"compressed\":\n          //   return new Response(hippo, {headers: {\"Content-Type\": \"image/svg+xml\"}});\n        default:\n          return new Response(\"Not found\", {status: 404});\n      }\n    });\n  }\n}\n\n\nasync function handleApiRequest(path, request, env) {\n  // We've received at API request. Route the request based on the path.\n\n  switch (path[0]) {\n    case \"room\": {\n      // Request for `/api/room/...`.\n\n      if (!path[1]) {\n        // The request is for just \"/api/room\", with no ID.\n        if (request.method == \"POST\") {\n          // POST to /api/room creates a private room.\n          //\n          // Incidentally, this code doesn't actually store anything. It just generates a valid\n          // unique ID for this namespace. Each durable object namespace has its own ID space, but\n          // IDs from one namespace are not valid for any other.\n          //\n          // The IDs returned by `newUniqueId()` are unguessable, so are a valid way to implement\n          // \"anyone with the link can access\" sharing. Additionally, IDs generated this way have\n          // a performance benefit over IDs generated from names: When a unique ID is generated,\n          // the system knows it is unique without having to communicate with the rest of the\n          // world -- i.e., there is no way that someone in the UK and someone in New Zealand\n          // could coincidentally create the same ID at the same time, because unique IDs are,\n          // well, unique!\n          let id = env.rooms.newUniqueId();\n          return new Response(id.toString(), {headers: {\"Access-Control-Allow-Origin\": \"*\"}});\n        } else {\n          // If we wanted to support returning a list of public rooms, this might be a place to do\n          // it. The list of room names might be a good thing to store in KV, though a singleton\n          // Durable Object is also a possibility as long as the Cache API is used to cache reads.\n          // (A caching layer would be needed because a single Durable Object is single-threaded,\n          // so the amount of traffic it can handle is limited. Also, caching would improve latency\n          // for users who don't happen to be located close to the singleton.)\n          //\n          // For this demo, though, we're not implementing a public room list, mainly because\n          // inevitably some trolls would probably register a bunch of offensive room names. Sigh.\n          return new Response(\"Method not allowed\", {status: 405});\n        }\n      }\n\n      // OK, the request is for `/api/room/<name>/...`. It's time to route to the Durable Object\n      // for the specific room.\n      let name = path[1];\n\n      // Each Durable Object has a 256-bit unique ID. IDs can be derived from string names, or\n      // chosen randomly by the system.\n      let id;\n      if (name.match(/^[0-9a-f]{64}$/)) {\n        // The name is 64 hex digits, so let's assume it actually just encodes an ID. We use this\n        // for private rooms. `idFromString()` simply parses the text as a hex encoding of the raw\n        // ID (and verifies that this is a valid ID for this namespace).\n        id = env.rooms.idFromString(name);\n      } else if (name.length <= 32) {\n        // Treat as a string room name (limited to 32 characters). `idFromName()` consistently\n        // derives an ID from a string.\n        id = env.rooms.idFromName(name);\n      } else {\n        return new Response(\"Name too long\", {status: 404});\n      }\n\n      // Get the Durable Object stub for this room! The stub is a client object that can be used\n      // to send messages to the remote Durable Object instance. The stub is returned immediately;\n      // there is no need to await it. This is important because you would not want to wait for\n      // a network round trip before you could start sending requests. Since Durable Objects are\n      // created on-demand when the ID is first used, there's nothing to wait for anyway; we know\n      // an object will be available somewhere to receive our requests.\n      let roomObject = env.rooms.get(id);\n\n      // Compute a new URL with `/api/room/<name>` removed. We'll forward the rest of the path\n      // to the Durable Object.\n      let newUrl = new URL(request.url);\n      newUrl.pathname = \"/\" + path.slice(2).join(\"/\");\n\n      // Send the request to the object. The `fetch()` method of a Durable Object stub has the\n      // same signature as the global `fetch()` function, but the request is always sent to the\n      // object, regardless of the request's URL.\n      return roomObject.fetch(newUrl, request);\n    }\n\n    default:\n      return new Response(\"Not found\", {status: 404});\n  }\n}\n\n// =======================================================================================\n// The ChatRoom Durable Object Class\n\n// ChatRoom implements a Durable Object that coordinates an individual chat room. Participants\n// connect to the room using WebSockets, and the room broadcasts messages from each participant\n// to all others.\nexport class ChatRoom {\n  constructor(state, env) {\n    this.state = state\n\n    // `state.storage` provides access to our durable storage. It provides a simple KV\n    // get()/put() interface.\n    this.storage = state.storage;\n\n    // `env` is our environment bindings (discussed earlier).\n    this.env = env;\n\n    // We will track metadata for each client WebSocket object in `sessions`.\n    this.sessions = new Map();\n    this.state.getWebSockets().forEach((webSocket) => {\n      // The constructor may have been called when waking up from hibernation,\n      // so get previously serialized metadata for any existing WebSockets.\n      let meta = webSocket.deserializeAttachment();\n\n      // Set up our rate limiter client.\n      // The client itself can't have been in the attachment, because structured clone doesn't work on functions.\n      // DO ids aren't cloneable, restore the ID from its hex string\n      let limiterId = this.env.limiters.idFromString(meta.limiterId);\n      let limiter = new RateLimiterClient(\n        () => this.env.limiters.get(limiterId),\n        err => webSocket.close(1011, err.stack));\n\n      // We don't send any messages to the client until it has sent us the initial user info\n      // message. Until then, we will queue messages in `session.blockedMessages`.\n      // This could have been arbitrarily large, so we won't put it in the attachment.\n      let blockedMessages = [];\n      this.sessions.set(webSocket, { ...meta, limiter, blockedMessages });\n    });\n\n    // We keep track of the last-seen message's timestamp just so that we can assign monotonically\n    // increasing timestamps even if multiple messages arrive simultaneously (see below). There's\n    // no need to store this to disk since we assume if the object is destroyed and recreated, much\n    // more than a millisecond will have gone by.\n    this.lastTimestamp = 0;\n  }\n\n  // The system will call fetch() whenever an HTTP request is sent to this Object. Such requests\n  // can only be sent from other Worker code, such as the code above; these requests don't come\n  // directly from the internet. In the future, we will support other formats than HTTP for these\n  // communications, but we started with HTTP for its familiarity.\n  async fetch(request) {\n    return await handleErrors(request, async () => {\n      let url = new URL(request.url);\n\n      switch (url.pathname) {\n        case \"/websocket\": {\n          // The request is to `/api/room/<name>/websocket`. A client is trying to establish a new\n          // WebSocket session.\n          if (request.headers.get(\"Upgrade\") != \"websocket\") {\n            return new Response(\"expected websocket\", {status: 400});\n          }\n\n          // Get the client's IP address for use with the rate limiter.\n          let ip = request.headers.get(\"CF-Connecting-IP\");\n\n          // To accept the WebSocket request, we create a WebSocketPair (which is like a socketpair,\n          // i.e. two WebSockets that talk to each other), we return one end of the pair in the\n          // response, and we operate on the other end. Note that this API is not part of the\n          // Fetch API standard; unfortunately, the Fetch API / Service Workers specs do not define\n          // any way to act as a WebSocket server today.\n          let pair = new WebSocketPair();\n\n          // We're going to take pair[1] as our end, and return pair[0] to the client.\n          await this.handleSession(pair[1], ip);\n\n          // Now we return the other end of the pair to the client.\n          return new Response(null, { status: 101, webSocket: pair[0] });\n        }\n\n        default:\n          return new Response(\"Not found\", {status: 404});\n      }\n    });\n  }\n\n  // handleSession() implements our WebSocket-based chat protocol.\n  async handleSession(webSocket, ip) {\n    // Accept our end of the WebSocket. This tells the runtime that we'll be terminating the\n    // WebSocket in JavaScript, not sending it elsewhere.\n    this.state.acceptWebSocket(webSocket);\n\n    // Set up our rate limiter client.\n    let limiterId = this.env.limiters.idFromName(ip);\n    let limiter = new RateLimiterClient(\n        () => this.env.limiters.get(limiterId),\n        err => webSocket.close(1011, err.stack));\n\n    // Create our session and add it to the sessions map.\n    let session = { limiterId, limiter, blockedMessages: [] };\n    // attach limiterId to the webSocket so it survives hibernation\n    webSocket.serializeAttachment({ ...webSocket.deserializeAttachment(), limiterId: limiterId.toString() });\n    this.sessions.set(webSocket, session);\n\n    // Queue \"join\" messages for all online users, to populate the client's roster.\n    for (let otherSession of this.sessions.values()) {\n      if (otherSession.name) {\n        session.blockedMessages.push(JSON.stringify({joined: otherSession.name}));\n      }\n    }\n\n    // Load the last 100 messages from the chat history stored on disk, and send them to the\n    // client.\n    let storage = await this.storage.list({reverse: true, limit: 100});\n    let backlog = [...storage.values()];\n    backlog.reverse();\n    backlog.forEach(value => {\n      session.blockedMessages.push(value);\n    });\n  }\n\n  async webSocketMessage(webSocket, msg) {\n    try {\n      let session = this.sessions.get(webSocket);\n      if (session.quit) {\n        // Whoops, when trying to send to this WebSocket in the past, it threw an exception and\n        // we marked it broken. But somehow we got another message? I guess try sending a\n        // close(), which might throw, in which case we'll try to send an error, which will also\n        // throw, and whatever, at least we won't accept the message. (This probably can't\n        // actually happen. This is defensive coding.)\n        webSocket.close(1011, \"WebSocket broken.\");\n        return;\n      }\n\n      // Check if the user is over their rate limit and reject the message if so.\n      if (!session.limiter.checkLimit()) {\n        webSocket.send(JSON.stringify({\n          error: \"Your IP is being rate-limited, please try again later.\"\n        }));\n        return;\n      }\n\n      // I guess we'll use JSON.\n      let data = JSON.parse(msg);\n\n      if (!session.name) {\n        // The first message the client sends is the user info message with their name. Save it\n        // into their session object.\n        session.name = \"\" + (data.name || \"anonymous\");\n        // attach name to the webSocket so it survives hibernation\n        webSocket.serializeAttachment({ ...webSocket.deserializeAttachment(), name: session.name });\n\n        // Don't let people use ridiculously long names. (This is also enforced on the client,\n        // so if they get here they are not using the intended client.)\n        if (session.name.length > 32) {\n          webSocket.send(JSON.stringify({error: \"Name too long.\"}));\n          webSocket.close(1009, \"Name too long.\");\n          return;\n        }\n\n        // Deliver all the messages we queued up since the user connected.\n        session.blockedMessages.forEach(queued => {\n          webSocket.send(queued);\n        });\n        delete session.blockedMessages;\n\n        // Broadcast to all other connections that this user has joined.\n        this.broadcast({joined: session.name});\n\n        webSocket.send(JSON.stringify({ready: true}));\n        return;\n      }\n\n      // Construct sanitized message for storage and broadcast.\n      data = { name: session.name, message: \"\" + data.message };\n\n      // Block people from sending overly long messages. This is also enforced on the client,\n      // so to trigger this the user must be bypassing the client code.\n      if (data.message.length > 256) {\n        webSocket.send(JSON.stringify({error: \"Message too long.\"}));\n        return;\n      }\n\n      // Add timestamp. Here's where this.lastTimestamp comes in -- if we receive a bunch of\n      // messages at the same time (or if the clock somehow goes backwards????), we'll assign\n      // them sequential timestamps, so at least the ordering is maintained.\n      data.timestamp = Math.max(Date.now(), this.lastTimestamp + 1);\n      this.lastTimestamp = data.timestamp;\n\n      // Broadcast the message to all other WebSockets.\n      let dataStr = JSON.stringify(data);\n      this.broadcast(dataStr);\n\n      // Save message.\n      let key = new Date(data.timestamp).toISOString();\n      await this.storage.put(key, dataStr);\n    } catch (err) {\n      // Report any exceptions directly back to the client. As with our handleErrors() this\n      // probably isn't what you'd want to do in production, but it's convenient when testing.\n      webSocket.send(JSON.stringify({error: err.stack}));\n    }\n  }\n\n  // On \"close\" and \"error\" events, remove the WebSocket from the sessions list and broadcast\n  // a quit message.\n  async closeOrErrorHandler(webSocket) {\n    let session = this.sessions.get(webSocket) || {};\n    session.quit = true;\n    this.sessions.delete(webSocket);\n    if (session.name) {\n      this.broadcast({quit: session.name});\n    }\n  }\n\n  async webSocketClose(webSocket, code, reason, wasClean) {\n    this.closeOrErrorHandler(webSocket)\n  }\n\n  async webSocketError(webSocket, error) {\n    this.closeOrErrorHandler(webSocket)\n  }\n\n  // broadcast() broadcasts a message to all clients.\n  broadcast(message) {\n    // Apply JSON if we weren't given a string to start with.\n    if (typeof message !== \"string\") {\n      message = JSON.stringify(message);\n    }\n\n    // Iterate over all the sessions sending them messages.\n    let quitters = [];\n    this.sessions.forEach((session, webSocket) => {\n      if (session.name) {\n        try {\n          webSocket.send(message);\n        } catch (err) {\n          // Whoops, this connection is dead. Remove it from the map and arrange to notify\n          // everyone below.\n          session.quit = true;\n          quitters.push(session);\n          this.sessions.delete(webSocket);\n        }\n      } else {\n        // This session hasn't sent the initial user info message yet, so we're not sending them\n        // messages yet (no secret lurking!). Queue the message to be sent later.\n        session.blockedMessages.push(message);\n      }\n    });\n\n    quitters.forEach(quitter => {\n      if (quitter.name) {\n        this.broadcast({quit: quitter.name});\n      }\n    });\n  }\n}\n\n// =======================================================================================\n// The RateLimiter Durable Object class.\n\n// RateLimiter implements a Durable Object that tracks the frequency of messages from a particular\n// source and decides when messages should be dropped because the source is sending too many\n// messages.\n//\n// We utilize this in ChatRoom, above, to apply a per-IP-address rate limit. These limits are\n// global, i.e. they apply across all chat rooms, so if a user spams one chat room, they will find\n// themselves rate limited in all other chat rooms simultaneously.\nexport class RateLimiter {\n  constructor(state, env) {\n    // Timestamp at which this IP will next be allowed to send a message. Start in the distant\n    // past, i.e. the IP can send a message now.\n    this.nextAllowedTime = 0;\n  }\n\n  // Our protocol is: POST when the IP performs an action, or GET to simply read the current limit.\n  // Either way, the result is the number of seconds to wait before allowing the IP to perform its\n  // next action.\n  async fetch(request) {\n    return await handleErrors(request, async () => {\n      let now = Date.now() / 1000;\n\n      this.nextAllowedTime = Math.max(now, this.nextAllowedTime);\n\n      if (request.method == \"POST\") {\n        // POST request means the user performed an action.\n        // We allow one action per 5 seconds.\n        this.nextAllowedTime += 5;\n      }\n\n      // Return the number of seconds that the client needs to wait.\n      //\n      // We provide a \"grace\" period of 20 seconds, meaning that the client can make 4-5 requests\n      // in a quick burst before they start being limited.\n      let cooldown = Math.max(0, this.nextAllowedTime - now - 20);\n      return new Response(cooldown);\n    })\n  }\n}\n\n// RateLimiterClient implements rate limiting logic on the caller's side.\nclass RateLimiterClient {\n  // The constructor takes two functions:\n  // * getLimiterStub() returns a new Durable Object stub for the RateLimiter object that manages\n  //   the limit. This may be called multiple times as needed to reconnect, if the connection is\n  //   lost.\n  // * reportError(err) is called when something goes wrong and the rate limiter is broken. It\n  //   should probably disconnect the client, so that they can reconnect and start over.\n  constructor(getLimiterStub, reportError) {\n    this.getLimiterStub = getLimiterStub;\n    this.reportError = reportError;\n\n    // Call the callback to get the initial stub.\n    this.limiter = getLimiterStub();\n\n    // When `inCooldown` is true, the rate limit is currently applied and checkLimit() will return\n    // false.\n    this.inCooldown = false;\n  }\n\n  // Call checkLimit() when a message is received to decide if it should be blocked due to the\n  // rate limit. Returns `true` if the message should be accepted, `false` to reject.\n  checkLimit() {\n    if (this.inCooldown) {\n      return false;\n    }\n    this.inCooldown = true;\n    this.callLimiter();\n    return true;\n  }\n\n  // callLimiter() is an internal method which talks to the rate limiter.\n  async callLimiter() {\n    try {\n      let response;\n      try {\n        // Currently, fetch() needs a valid URL even though it's not actually going to the\n        // internet. We may loosen this in the future to accept an arbitrary string. But for now,\n        // we have to provide a dummy URL that will be ignored at the other end anyway.\n        response = await this.limiter.fetch(\"https://dummy-url\", {method: \"POST\"});\n      } catch (err) {\n        // `fetch()` threw an exception. This is probably because the limiter has been\n        // disconnected. Stubs implement E-order semantics, meaning that calls to the same stub\n        // are delivered to the remote object in order, until the stub becomes disconnected, after\n        // which point all further calls fail. This guarantee makes a lot of complex interaction\n        // patterns easier, but it means we must be prepared for the occasional disconnect, as\n        // networks are inherently unreliable.\n        //\n        // Anyway, get a new limiter and try again. If it fails again, something else is probably\n        // wrong.\n        this.limiter = this.getLimiterStub();\n        response = await this.limiter.fetch(\"https://dummy-url\", {method: \"POST\"});\n      }\n\n      // The response indicates how long we want to pause before accepting more requests.\n      let cooldown = +(await response.text());\n      await new Promise(resolve => setTimeout(resolve, cooldown * 1000));\n\n      // Done waiting.\n      this.inCooldown = false;\n    } catch (err) {\n      this.reportError(err);\n    }\n  }\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","async","handleErrors","request","func","err","headers","pair","WebSocketPair","accept","send","JSON","stringify","error","stack","close","Response","status","webSocket","env","path","URL","url","pathname","slice","split","method","id","rooms","newUniqueId","toString","name","match","idFromString","length","idFromName","roomObject","newUrl","join","fetch","handleApiRequest","ChatRoom","constructor","state","this","storage","sessions","Map","getWebSockets","forEach","meta","deserializeAttachment","limiterId","limiters","limiter","RateLimiterClient","set","blockedMessages","lastTimestamp","ip","handleSession","acceptWebSocket","session","serializeAttachment","otherSession","values","push","joined","backlog","list","reverse","limit","webSocketMessage","msg","quit","checkLimit","data","parse","queued","broadcast","ready","message","timestamp","Math","max","Date","now","dataStr","toISOString","put","closeOrErrorHandler","delete","webSocketClose","code","reason","wasClean","webSocketError","quitters","quitter","RateLimiter","nextAllowedTime","cooldown","getLimiterStub","reportError","inCooldown","callLimiter","response","text","Promise","resolve","setTimeout"],"sourceRoot":""}